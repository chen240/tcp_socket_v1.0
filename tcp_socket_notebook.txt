1.socket套接字编程
  1.目标：根据scoket模块提供的接口函数，进行组合使用完成基于tcp
          和udp的网络哦编程。
	  （有图片）
  2.套接字：完成上述目标的编程手段，编程方案。
  3.套接字分类：
     流式套接字（SOCK_STREAM）：传输层基于tcp协议的的套接字编程方案。
     数据报套接字(SOCK_DGRAM):传输层基于udp协议的套接字编程方案。
     底层套接字(SOCK_RAM):访问底层协议的套接字编程

     *面向连接的传输--tcp协议--可靠的--流式套接字
     *面向无连接传输--udp协议--不可靠--数据报套接字
2.tcp套接字服务端编程
   <图片>--相当于接一个电话
   import socket  -->标准库模块
   1.创建套接字                        ipv4  AF_INET6--ipv6
     sockfd=socket.socket(sock_family=AF_INET,
                          socket_type=SOCK_STREAM,
			  proto=0)
    功能：创建套接字
    参数：socket_family:选择地址族类型 AF_INET 
          socket_type:套接字类型 SOCK_STREAM 流式（默认）
	                         SOCK_DRGAM 数据报
	  proto:选择子协议类型 一般为0
    返回值：返回套接字对象
   2.绑定服务端地址
    sockfd.bind(addr)
    功能：绑定IP地址
    参数：元组 (ip,port)
    本机访问：127.0.0.1

    localhost  可以被本机用 127.0.0.1
    127.0.0.1 同上
    192.168.205.127 可以被别人用192.168.205.127访问
    0.0.0.0 可以被别人用192.168.205.127访问
            也可以被自己用127.0.0.1访问
   3.设置监听套接字---》只针对tcp
     sockfd.listen（n）
     功能：将套接字设置为监听套接字，创建监听队列
     参数: n表示监听队列大小

     *一个监听套接字可以连接多个客户端套接字
     理解：实现三次挥手过程时
   4.等待处理客户端连接请求
     connfd,addr=sockfd.accept()
     功能：阻塞等待处理客户端连接
     返回值： connfd 客户端连接套接字
              addr 连接的客户端地址
      *阻塞函数：程序运行过程中遇到阻塞函数则暂停运行，直到某种阻塞条件达成再继续运行。
      <图片解释>
   5.消息收发
     connfd.recv(buffersize)
     功能：接收对应客户端消息
     参数：一次最多接收多少字节
     返回值：接收的内容

     *如果没有消息则会阻塞

     n=connfd.send(data)
     功能：发送消息给对应客户端
     参数：要发送的内容，必须时byte格式
     返回值：返回实际发送消息的大小
   6.关闭套接字
    sockfd.close()
    功能：关闭套接字
3.tcp客户端
  1.创建套接字
   *必须相同类型的套接字才能通信
  2.建立连接
   sockfd.connect(servr_addr)
   功能：建立连接
   参数：元组，服务端地址
  3.消息收发
    *消息收发要和服务端配合，避免两边都出现recv阻塞
  4.关闭套接字

作业：
  1.总结口述方案
    1.OSI七层模型和tcp/ip模型
    2.三次握手和四次挥手过程
    3.tcp和udp的区别
  2.将完成的基本的tcp_server tcp_client改写为一个当
    客户端输入特殊字符后可以继续接收下个客户端请求的程序。
  3.复习文件的读写seek操作

  1.OSI七层模型-->网络通信工作流程的标准化
    
    应用层：提供用户服务，具体功能由特定的程序而定
    表示层：数据的压缩优化，加密
    会话层：建立应用级的连接，选择传输服务
    传输层：提供不同的传输服务，流量控制

    网络层：路由选择，网络互联
    链路层：进行数据交换，具体消息的发送，链路连接
    物理层：物理硬件，接口设定，网卡路由交换机等
  2.五层模型(TCP/IP模型)
    应用层：应用层 表示层 会话层
    传输层
    网络层
    物理层
    链路层
  3.网络协议：在网络通信中双方都遵循的规定，包括建立什么样的
   网络哦结构，消息结构，标识代表什么等
    
    应用层:TETP HTTP DNS SMTP
    传输层:TCP UDP
    网络层:IP
    物理层：IEEEE
  4.三次握手和四次挥手
    三次握手：tcp传输在数据传输前建立连接和断开的确认
      1.客户端向服务端发送连接请求
      2.服务端收到请求后，回复确认消息，表示允许连接
      3.客户端收到服务器回复，发送最终标志位确认连接
    四次挥手：tcp传输在连接断开前进行断开确认的过程
      1.主动方发送报文告知被动方要断开连接
      2.被动方收到请求后立即返回报文告知已经准备断开
      3.被动方准备就绪后再次发送报文告知可以断开
      4.主动方发送消息，确认最终断开
4.套接字传输注意事项
  1.监听套接字存在客户端即可发起连接，但是最终连接的处理需要
    accept进行处理。
  2.如果连接的另外一端退出，则recv会立即返回空子串不再阻塞
  3.当连接的另一端退出时，再试图send发送就会产生
    BrokenPipeError
5.网络的收发缓冲区
   <图片演示>
   发送缓冲区------>接收缓冲区
    send-------------->recv
   缓冲区作用：协调收发(处理速度)
               减少交互次数


   send和recv实际上是和缓冲区进行交互，发送缓冲区满时就无法
   发送，接收缓冲区满时recv才阻塞

6.TCP粘包
   产生原因:tcp套接字以字节流方式传输，没有消息边界，发送
            和接收并不能保证每次发送都及时地被接收。
   影响：如果每次发送内容表达一个独立的含义此时可能需要处理
         粘包防止产生歧义
   处理方法:
     1.每次发送消息添加结尾标志(人为增加消息边界)
     2.发送数据结构体
        "Y 18 abcd...."
     3.协调收发速度，每次发送后都预留接收时间。

----------------------------------------
cookie:
  1.github是一个开源项目社区网站。拥有全球最多的开源项目。
    开发者可以注册这个网站建立自己的github仓库。然后就可以
    在本地通过git像操作远程仓库一样操作github仓库。
  2.github：https://github.com
  
  3.添加ssh密钥
     1.在本地主机生成ssh密钥对
        ssh-keygen
	
	*默认密钥对存放在~/.ssh/ 下
	*生成过程会提示甚至密码。如果直接回车则表示不设置密码
     2.进入~/.ssh目录 复制 id_rsa.pub 公钥内容
     3.登陆github账号
        右上角头像下拉菜单-->seetings--->SSH--->左侧
	SSH and GPG keys--->new ssh key-->填写title,将
	复制内容加入key文本框 点击add...
     4.创建新的github仓库
       1.右上角+下拉菜单-->new repository-->填写参考名和基本描述
       ，根据情况是否添加readme等内容，选择共有还是私有-->点击创建
     5.操作github仓库
       1.git remote 连接远程github仓库 如果需要输入密码输入
         github密码即可
       2.使用git push 等操作远程仓库的方法操作即可






